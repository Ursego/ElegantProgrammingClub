// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// Break your program into short, focused methods that each do one identifiable task (separation of concerns).
// ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

The result is simpler, clearer code—even in very complex systems—and makes understanding, debugging, and maintaining enterprise applications much easier.

The ancient maxim "divide et impera" proved a potent tool for emperors seeking to maintain control over vast and often disparate territories.
By strategically fostering divisions among potentially powerful factions, be it through playing on existing rivalries or creating new ones, emperors could prevent unified opposition
	from forming, thus weakening any threats to their authority and ensuring their continued rule.
This principle of breaking down large, complex entities into smaller, more manageable parts finds a compelling parallel in programming.
The "divide and conquer" paradigm in software involves breaking down a large, intricate problem into smaller, independent subproblems that are easier to solve individually.
Once these smaller solutions are obtained, they are combined to solve the original, more complex problem.
This approach not only simplifies the development process but also often leads to more efficient and maintainable code.

A BIG PROGRAM SHOULD ALWAYS BE WRITTEN IN SMALL PIECES

If your executable sections stretch across hundreds of lines—with a loop starting on page 2 and ending on page 6—it becomes nearly impossible to follow the function's logic.
The full picture of what the function is doing gets buried under a pile of numerous low-level details.

So even if an overgrown fragment of a function is executed only once, extract it into its own function—don’t wait for it to be reused in more than one place
(though potential reuse is a good reason too—see https://github.com/Ursego/ElegantProgrammingClub/blob/main/Avoid%20code%20duplication.cs).

KEEP ALL OF THE OPERATIONS IN A METHOD AT THE SAME LEVEL OF ABSTRACTION

This will naturally result in programs with many small methods.
Programming is all about managing complexity, and short, single-purpose functions help achieve that
Mixing different levels of abstraction within a function, on the other hand, always leads to confusion.

The more lines in a method, the harder it is to understand what it does, so it’s very difficult to grasp the logic behind one massive, tangled, toilet-paper-long method.
To figure out what’s going on, readers are forced to deal with a messy mix of code—all jumbled together, even though the logic clearly belongs to different abstraction levels.
Readers may struggle to tell whether a specific expression represents a core concept or just a low-level detail.
Even worse, once details are mixed with essential logic, more and more details tend to accumulate in the function over time.

THE STEP-WISE REFINEMENT (AKA "TOP-DOWN DECOMPOSITION") PRINCIPLE

Instead of diving into all the details immediately, we want the code to read like a top-down narrative.
Start with the top-level ("main") function. It should resemble the table of contents of the book, not its main text.
That top-level function should call clearly named sub-functions, which can themselves call sub-sub-functions representing the next levels of abstraction, and so on.

This hierarchy lets developers read the program, descending one level of abstraction at a time and always focusing on just it.
The result is that at any given level of refinement, you can fully understand its logic without being overwhelmed.

To get a general idea of the functionality, it’s usually enough to look at the top-level function.
You’ll dig into the sub-functions only if absolutely necessary—and in most cases, you won’t need to if the sub-functions have quality names.
So why clutter your view with code that’s rarely needed to be investigated, especially if it hides the "big picture"?

ONE (<- !!!) IDENTIFIABLE TASK

When we say that each method should perform one identifiable task, focus on the word "one."

The next time you're tempted to group multiple actions into a single method, remember that the English language doesn’t have a word like MakeUpYourRoomBeQuietAndDoYourHomeWork,
even though that would be convenient for something often said.

If you need to perform three different actions, write three separate methods.
That way, you’ll already have the pieces ready if you—or another developer—need to call just one of them later. The smaller the LEGO bricks, the more flexibility you have. 

On the other hand, if you write one method that does too much, you'll eventually face a "siamese twin separation surgery"—refactoring part of that method into a new one.
That also means you’ll need extra regression testing to make sure nothing breaks for the existing consumers of your (former) all-in-one method.

I once did exactly that. But my manager told me to roll everything back—we can't touch other, well-functioning flows. He told me to just copy/paste the needed fragment.
<sarcasm>Good management is the key to a successful project!</sarcasm>

Bad code tries to do too much. Clean code stays focused and does one thing well. It reflects a single purpose, undistracted and unpolluted by unrelated surrounding details.
It’s no coincidence that many software design principles can be summed up by this simple rule.

BUT WHAT DOES “ONE TASK” ACTUALLY MEAN?

If a function performs only those steps that are one level below the function’s name, then it’s doing one task.
After all, we write functions to break down a larger concept—the function’s name—into smaller steps at the next level of abstraction.

Another way to tell if a function is doing more than one task is if you can extract a new function from it and give that new function a name that’s not just a restatement
of the original implementation.

ONE IDENTIFIABLE (<- !!!) TASK

The purpose, intention and responsibility of the code must be obvious. Dependencies should be minimal.
Future maintainers may need to modify the code due to changing requirements or bug fixes, so don't mislead them.
We must make not only the interfaces of our code easy to understand, but also apply the same principle to the implementation itself.
Otherwise, a future maintainer might rewrite that code without realizing it's not semantically equivalent, which will create bugs.
Clear intent is especially crucial in the presence of complex conditions, tricky logic, advanced algorithms or data structures, and less common language features.

Bad code has an ambiguous purpose. Clean code is straightforward to make it hard for bugs to hide.